<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ClipOpera Neon Generator</title>
<script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
<style>
  body {
    background: linear-gradient(to right, #0f0f0f, #1a1a1a);
    color: #39ff14;
    font-family: 'Courier New', monospace;
    text-align: center;
    padding: 20px;
  }
  select, input, button {
    font-family: inherit;
    font-size: 16px;
    margin: 10px;
    padding: 8px;
    background: #222;
    border: 2px solid #39ff14;
    color: #39ff14;
    border-radius: 5px;
    box-shadow: 0 0 10px #39ff14;
    cursor: pointer;
  }
  input[type="text"] {
    width: 300px;
  }
  canvas {
    display: block;
    margin: 20px auto;
    border: 3px solid #39ff14;
    box-shadow: 0 0 15px #39ff14;
    background-color: #000;
  }
</style>
</head>
<body>
<h1>ðŸŽ¬ ClipOpera Neon Generator ðŸŽ¬</h1>
<script>
let fitMode = 'contain';
let imageURL = null;
let audioURL = null;
const imgEl = new Image();
let userText = "NEON CITY";

const controlsContainer = document.createElement('div');
document.body.appendChild(controlsContainer);

const select = document.createElement('select');
select.id = 'fitModeSelector';
select.innerHTML = `<option value="contain">Contain</option><option value="cover">Cover</option>`;
select.onchange = e => {
  fitMode = e.target.value;
  if (imgEl.src) updatePreview();
};
controlsContainer.appendChild(select);

const textInput = document.createElement('input');
textInput.type = 'text';
textInput.value = userText;
textInput.placeholder = 'Overlay text';
textInput.oninput = e => {
  userText = e.target.value;
  if (imgEl.src) updatePreview();
};
controlsContainer.appendChild(textInput);

const imageUpload = document.createElement('input');
imageUpload.type = 'file';
imageUpload.accept = 'image/*';
imageUpload.onchange = e => {
  const file = e.target.files[0];
  if (file) {
    if (imageURL) URL.revokeObjectURL(imageURL);
    imageURL = URL.createObjectURL(file);
    imgEl.src = imageURL;
    imgEl.onload = () => updatePreview();
  }
};
controlsContainer.appendChild(document.createTextNode(' Image: '));
controlsContainer.appendChild(imageUpload);

const audioUpload = document.createElement('input');
audioUpload.type = 'file';
audioUpload.accept = 'audio/*';
audioUpload.onchange = e => {
    const file = e.target.files[0];
    if (file) {
        if (audioURL) URL.revokeObjectURL(audioURL);
        audioURL = URL.createObjectURL(file);
        alert('Audio file selected!');
    }
};
controlsContainer.appendChild(document.createTextNode(' Audio: '));
controlsContainer.appendChild(audioUpload);

const exportGifBtn = document.createElement('button');
exportGifBtn.textContent = 'ðŸ–¼ï¸ Export Animated GIF';
exportGifBtn.onclick = exportAnimatedGif;
controlsContainer.appendChild(exportGifBtn);

const exportMp4Btn = document.createElement('button');
exportMp4Btn.textContent = 'ðŸŽ¥ Export MP4 Video';
exportMp4Btn.onclick = async () => {
    const blob = await generateVideoBlob(exportMp4Btn);
    if (!blob) return;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "clipopera_video.mp4";
    a.click();
    URL.revokeObjectURL(url);
};
controlsContainer.appendChild(exportMp4Btn);

const previewCanvas = document.createElement('canvas');
previewCanvas.id = 'fitPreview';
previewCanvas.width = 300;
previewCanvas.height = 480;
document.body.appendChild(previewCanvas);
const previewCtx = previewCanvas.getContext('2d');

function updatePreview() {
  if (!imgEl.naturalWidth) return;
  const fit = calculateAspectFit(imgEl.naturalWidth, imgEl.naturalHeight, previewCanvas.width, previewCanvas.height, fitMode);
  previewCtx.fillStyle = 'black';
  previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
  previewCtx.drawImage(imgEl, fit.x, fit.y, fit.width, fit.height);
  previewCtx.font = "bold 24px 'Courier New', monospace";
  previewCtx.textAlign = 'center';
  previewCtx.shadowColor = '#39ff14';
  previewCtx.shadowBlur = 10;
  previewCtx.fillStyle = '#39ff14';
  previewCtx.fillText(userText.toUpperCase(), previewCanvas.width / 2, previewCanvas.height - 30);
  previewCtx.shadowBlur = 0;
  previewCtx.fillStyle = '#fff';
  previewCtx.fillText(userText.toUpperCase(), previewCanvas.width / 2, previewCanvas.height - 30);
}

function calculateAspectFit(srcWidth, srcHeight, maxWidth, maxHeight, mode = 'contain') {
  const srcAspect = srcWidth / srcHeight;
  const targetAspect = maxWidth / maxHeight;
  let width, height, x = 0, y = 0;
  if (mode === 'cover') {
    if (srcAspect > targetAspect) {
      height = maxHeight;
      width = height * srcAspect;
      x = (maxWidth - width) / 2;
    } else {
      width = maxWidth;
      height = width / srcAspect;
      y = (maxHeight - height) / 2;
    }
  } else {
    const ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
    width = srcWidth * ratio;
    height = srcHeight * ratio;
    x = (maxWidth - width) / 2;
    y = (maxHeight - height) / 2;
  }
  return { width, height, x, y };
}

function exportAnimatedGif() {
  if (!imageURL) return alert('Please upload an image first.');
  const gif = new GIF({ workers: 2, quality: 10, width: previewCanvas.width, height: previewCanvas.height });
  gif.addFrame(previewCtx, { copy: true, delay: 1000 });
  gif.on('finished', blob => {
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = "clipopera_animation.gif";
    link.click();
    URL.revokeObjectURL(link.href);
  });
  gif.render();
}

async function generateVideoBlob(triggerButton) {
    if (!imageURL || !audioURL) {
        alert('Please upload both an image and an audio file first.');
        return null;
    }
    const originalText = triggerButton.textContent;
    triggerButton.textContent = 'Generating...';
    triggerButton.disabled = true;

    try {
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ff = createFFmpeg({ log: true });
        await ff.load();
        await ff.FS('writeFile', 'frame.png', await fetchFile(previewCanvas.toDataURL('image/png')));
        await ff.FS('writeFile', 'audio.mp3', await fetchFile(audioURL));
        await ff.run('-loop', '1', '-i', 'frame.png', '-i', 'audio.mp3', '-c:v', 'libx264', '-c:a', 'aac', '-pix_fmt', 'yuv420p', '-shortest', 'out.mp4');
        const data = ff.FS('readFile', 'out.mp4');
        ff.exit();
        return new Blob([data.buffer], { type: 'video/mp4' });
    } catch (error) {
        console.error("FFmpeg error:", error);
        alert("An error occurred during video generation.");
        return null;
    } finally {
        triggerButton.textContent = originalText;
        triggerButton.disabled = false;
    }
}

const notionTrigger = document.createElement('button');
notionTrigger.textContent = 'ðŸ“¤ Upload to Notion';
notionTrigger.onclick = () => alert('To implement Notion upload, you need a server-side proxy to protect your API key. The general flow is: Client -> Your Server -> Notion API.');
document.body.appendChild(notionTrigger);

const discordUpload = document.createElement('button');
discordUpload.textContent = 'ðŸš€ Upload to Discord';
discordUpload.onclick = async () => {
  const webhookURL = prompt("Please enter your Discord Webhook URL:");
  if (!webhookURL) return;

  const blob = await generateVideoBlob(discordUpload);
  if (!blob) return;

  discordUpload.textContent = "Uploading...";
  discordUpload.disabled = true;

  const formData = new FormData();
  formData.append('file', blob, 'clipopera_video.mp4');
  formData.append('content', `Generated via ClipOpera: **${userText.toUpperCase()}**`);

  try {
    const response = await fetch(webhookURL, { method: 'POST', body: formData });
    if (!response.ok) {
      const error = await response.json();
      alert(`Failed to upload. Discord says: ${error.message}`);
    } else {
      alert('Successfully uploaded to Discord!');
    }
  } catch (error) {
    console.error("Discord upload error:", error);
    alert("An error occurred during upload.");
  } finally {
    discordUpload.textContent = 'ðŸš€ Upload to Discord';
    discordUpload.disabled = false;
  }
};
document.body.appendChild(discordUpload);

const gdriveUpload = document.createElement('button');
gdriveUpload.textContent = 'ðŸ“ Upload to Google Drive';
gdriveUpload.onclick = () => alert(`To implement Google Drive upload:
1. Go to Google Cloud Console and create a new project.
2. Enable the "Google Drive API".
3. Create API credentials (API Key and OAuth 2.0 Client ID).
4. Use the Google API Client Library (gapi) to handle user login (OAuth) and make a multipart POST request to the 'files.create' endpoint.`);
document.body.appendChild(gdriveUpload);
</script>
</body>
</html>
